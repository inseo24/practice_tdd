# 1장 다중 통화를 지원하는 Money 객체

어떤 테스트가 있어서 보고서에 제대로 계산되도록 하는 코드가 완성됐다는 걸 확신할 수 있을까?

- 통화가 다른 두 금액을 더해 주엉진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

할일 목록을 작성해보자. 

- 어떤 일을 앞으로 해야 할지
- 지금 하는 일에 집중할 수 있고
- 언제 일이 다 끝나는지 알려줄 수 있는
- 작업을 시작하면 **굵은 글씨**로 표시하고
- 끝나면 ~~이렇게~~ 줄을 긋자

### 할일 목록

- $5 + 10CHF = $10(환율이 2:1일 경우)
- **$5 * 2 = $10**

### 테스트를 먼저 만들자

객체를 만들면서 시작하는게 아니라 테스트를 먼저 만들어야 한다.

어떤 테스트가 필요할까?

작은 것부터 시작하는게 좋다. 2번째 것부터 해보자.

테스트를 작성할 때는 오퍼레이션의 완벽한 인터페이스에 대해 상상해보는 것이 좋다. 우리는 지금 오퍼레이션이 외부에서 어떤 식으로 보일지에 대한 이야기를 테스트코드에 적고 있는 것이다. 가능한 최선의 API에서 시작해서 거꾸로 작업하는 것이 애초에 일을 복잡하고 보기 흉하며 ‘현실적'이게 하는 것보다 낫다.

다음은 간단한 곱셈의 예이다.

```kotlin
fun testMultiplication() {
	var five = Dollar(5)
	five.times(2)
	assertEquals(10, five.amount);
}
```

(불편러들을 위해 미리 말하자면 나도 안다! public field에다가 생각치 못한 부작용이 있을 수 있고, 금액 계산하는데 정수형을 사용한다. 하지만 작은 단계로 시작하는 것이다. 이런 문제들을 적어 놓고 계속 진행하자. 우리에겐 실패하는 테스트가 주어진 상태고 최대한 빨리 초록 막대를 보고 싶을 뿐이다.

### 할 일 목록 갱신!

- $5 + 10CHF = $10(환율이 2:1일 경우)
- **$5 * 2 = $10**
- amount를 private으로 만들기
- Dollar 부작용(side effect)?
- Money 반올림?

위에 작성한 코드는 컴파일 조차 되지 않는다. 여기서 4가지의 컴파일 에러가 있다.

- Dollar 클래스 없음
- 생성자가 없음
- times(int) 메서드 없음
- amount 필드가 없음

1번에 1개씩 정복하기로 하자.

우선 Dollar 클래스부터 만들자.

```kotlin
class Dollar
```

에러가 하나 없어졌다. 이제 생성자를 만들자.

그냥 컴파일만 되게 할 거니 생성자 안에서는 아무 일도 안해도 된다.

(원래 자바면 여기서 생성자만 만드는 코드가 써지고 amount 필드는 없는데 코틀린이라서 amount 필드도 만들어지고 생성자도 만들어짐)

```kotlin
class Dollar(
	val amount: Int
)
```

이제 에러가 2개 남았다. 이번엔 times()의 스텁 구현이 필요하다. 이번에도 역시 컴파일만 될 수 있게 해주는 최소한의 구현만 할 것이다.

```kotlin
fun times(mulitplier: Int) {
}
```

마지막으로 amount 필드를 추가하자.(생략)

야호! 이제 우리는 테스트가 실패하는 모습을 볼 수 있게 됐다.

우린 지금 공포의 빨간 막대를 보고 있다. 테스팅 프레임워크는 방금 우리가 만든 코드 조각을 실행한 후 그 결과로 ‘10’이 나와야 하는데 ‘0’이 나왔다는 것을 알려준다. **슬픈 일이다.**

아니지, 아니야.(?) 이것도 일종의 진척이다. 이제 실패에 대한 구체적인 척도를 갖게 된 것이다.

막연히 실패했다는 사실만 아는 것보다 나아진 것이다. 우리 문제는 ‘다중 통화 구현'에서 ‘이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기'로 변형된 것이다. 훨씬 간단하다. 범위도 훨씬 적어서 걱정이 줄었다. 이 테스트를 통과시키는 건 쉽다.

내가 제시할 해법이 마음에 안들지도 모른다. 하지만 당장의 목표는 완벽한 해법을 구하는 것이 아니라 테스트를 통과하는 것일 뿐이다. 후에 진리와 미의 제단에 제물을 바치게 될 것이다.

내가 상상할 수 있는 최소 작업은 다음과 같다.

```kotlin
class Dollar(
	val amount: Int = 10
)
```

(이렇게 할 경우 코틀린에서는 Dollar(5)에 5 값이 들어가서 테스트가 통과되진 않는다. 책의 자바 코드는 여기서 테스트가 통과되는데 코틀린으로 하니 그냥 테스트 코드에서 five = Dollar(10)을 넣어 성공시켜 봤다.)

테스트가 통과했다! 계속 진행하기 전에 일반화해야 한다. 주기는 다음과 같다.

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

우리는 주기의 1번부터 4번까지 수행했다. 이제 중복을 제거할 차례다. 

그런데 어디가 중복일까? 

이번 경우에는 중복이 테스트에 있는 데이터과 코드에 있는 데이터 사이에 존재한다. 

코드를 다음과 같이 썼다면 어땠을까?

```kotlin
var amount: Int = 5 * 2
```

여기서 10은 다른 곳에서 넘어온 값이다. 사실 우린 우리가 인식조차 할 수 없을 만큼 빨리 머릿속으로 곱셈을 수행한 것이다. 이제 5와 2가 두 곳에 존재한다. 따라서 우린 무자비하게 이 중복을 제거해야 한다.

5와 2를 한 번에 제거할 수 있는 방법은 없다. 하지만 객체의 초기화 단계에 있는 설정 코드를 times() 메서드 안으로 옮겨 보면 어떨까?

```kotlin
class Dollar(
  var amount: Int
) {
  fun times(multiplier: Int) {
      amount = 5 * 2
  }
}
```

테스트는 통과되고 테스트 막대 역시 초록색이다. 

이런 작은 단계를 밟을 능력을 갖춰야 한다. 직접 예제를 선택해서 작은 단계로 구현하는 연습을 해보기 바란다. 만약 정말 작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 될 것이다. 

그러나 큰 단계로만 작업했다면, 더 작은 단계가 적절한 경우에 대해 결코 알지 못하게 된다.

5를 어디서 얻을 수 있을까? 이건 생성자에서 넘어오는 값이니 이걸 다음과 같이 amount 변수에 저장하면 그걸 times에서 사용할 수 있다. 

```kotlin
class Dollar(
  var amount: Int
) {
  fun times(multiplier: Int) {
        amount *= 2
  }
}
```

‘multiplier’의 값이 2이므로, 상수를 이 인자로 대체할 수 있다.

```kotlin
package com.example.ddd

class Dollar(
    var amount: Int
) {

    fun times(multiplier: Int) {
        amount *= multiplier
    }
}
```

### 할 일 목록 1개 완료!

- $5 + 10CHF = $10(환율이 2:1일 경우)
- ~~$5 * 2 = $10~~
- amount를 private으로 만들기
- Dollar 부작용(side effect)?
- Money 반올림?

이제 첫 번째 테스트에 완료 표시를 할 수 있게 됐다. 다음 장부터는 Dollar 부작용에 대한 작업을 하게 될 것이다. 그 전에 지금까지 한 작업을 검토해보자. 우리는 다음 작업을 했다.

- 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다.
- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
- JUnit에 대한 상세한 사항들을 잠시 무시하기로 했다.
- 스텁 구현을 통해 테스트를 컴파일했다.
- 끔찍한 죄악을 범해 테스트를 통과시켰다.
- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.
- 새로운 할일들을 한 번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.