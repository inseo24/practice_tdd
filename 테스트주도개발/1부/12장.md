# 12장 드디어, 더하기

```
$5 + 10CHF = $10(환율이 2:1인 경우)
```

할 일 목록을 정리하고 옮겨보자.

```
$5 + 10CHF = $10(환율이 2:1인 경우)
**$5 + $5 = $10**
```

전체 더하기 기능에 대한 스토리를 어떻게 다 적을까?

간단하게 예시를 들어, ‘$5 + $5 = $10’ 에서 시작해보자.

```kotlin
@Test
fun testSimpleAddition() {
    val sum = Money.dollar(5).plus(Money.dollar(5))
    assertEquals(Money.dollar(10), sum)
}
```

테스트를 작성하더라도 생각을 깊게 해봐야 할 때가 있고, 그런 테스트가 있기 마련이다.

다중 통화 연산을 어떻게 표현할까가 그런 경우 중 하나다.

설계상 가장 어려운 제약은 다중 통화 사용에 대한 내용을 시스템의 나머지 코드에게 숨기고 싶다는 점이다. 

한 가지 가능한 전략은 모든 내부 값을 참조통화로 전환하는 것이다. 하지만 이 방식으로는 여러 환율을 쓰기가 어렵다.

대신, 편하게 여러 환율을 표현할 수 있으면서도 산술 연산 비슷한 표현들을 여전히 산술 연산처럼 다룰 수 있는 해법이 있으면 좋을 것 같다. 

객체가 우리를 구해줄 것이다. 가지고 있는 객체가 우리가 원하는 방식으로 동작하지 않을 경우엔 그 객체와 외부 프로토콜이 같으면서 내부 구현은 다른 새로운 객체(imposter)로 만들 수 있다.

여기서 imposter를 만들 생각을 하는 걸 어떻게 알 수 있을까? 번뜩이는 설계상의 착상을 가능케 해주는 공식 같은 건 없다. 이 ‘기교'는 워드 커닝엄이 십년 전에 만들었는데, 내가 아직까지는 워드와 관련 없는 사람이 독립적으로 사용한 걸 본 적이 없기 때문에 그 기교는 상당히 기교스러운 것이다. 

TDD는 적절한 때에 번뜩이는 통찰을 보장하지 못한다. 그렇지만 확신을 주는 테스트와 조심스럽게 정리된 코드를 통해, 통찰에 대한 준비와 함께 통찰이 번뜩일 때 그걸 적용할 준비를 할 수 있다.

해법은 Money와 비슷하게 동작하지만 사실은 두 Money의 합을 나타내는 객체를 만드는 것이다. 

이 아이디어를 설명하기 위한 몇 가지 다른 메타포를 생각해봤다. 

한 가지는 Money의 합을 마치 지갑처럼 취급하는 것이다. 한 지갑에는 금액과 통화가 다른 여러 화폐들이 들어갈 수 있다. 

또 다른 메타포는 ‘(2+3) * 5’와 같은 수식이다. 우리 경우엔 ‘($2 + 3CHF) * 5’가 되겠지만 이렇게 하면 Money를 수식의 가장 작은 단위로 볼 수 있다. 연산의 결과로 Expression들이 생기는데, 그 중 하나는 Sum(합)이 될 것이다. 연산이 완료되면 환율을 이용해서 결과 Expression을 단일 통화로 축약할 수 있다.

이 메타포를 테스트에 적용해보자. 마지막 줄은 다음과 같이 끝날 것이다.

```kotlin
assertEquals(Money.dollar(10), reduced)
```

reduced(축약된)란 이름의 Expression은 Expression에 환율을 적용함으로써 얻어진다. 실세계에서 환율이 적용되는 곳은 어디인가? 은행! 다음과 같이 쓸 수 있겠다.

```kotlin
val reduced = bank.reduce(sum, "USD")
assertEquals(Money.dollar(10), reduced)
```

(은행과 수식 메타포를 섞은 게 조금 이상하긴 하다. 일단 자초지종을 살펴보고 가치를 논하자.)

우린 지금 설계상 중요한 결정을 내렸다. 단순히 ‘...reduce = sum.reduce(”USD”, bank)’라고 쓸 수도 있었다. 왜 Bank가 reduce()를 수행하는 책임을 맡아야 할까? 한 가지 답은 “그게 제일 먼저 떠올랐다.”는 건데, 이건 별로 유익하지 않다. 왜 축약이 수식이 아닌 은행의 책임이어야 한다는 생각이 머리에 떠올렸을까? 현재 내가 설명할 수 있는 건 다음과 같다.

- Expression은 우리가 하려는 일의 핵심에 해당한다. 나는 핵심이 되는 객체가 다른 부분에 대해서 될 수 있는 한 모르도록 노력한다. 그렇게 하면 핵심 객체에 가능한 오랫 동안 유연할 수 있다. (게다가 테스트하기에 쉬울 뿐 아니라, 재활용하거나 이해하기에 모든 쉬운 상태로 남아 있을 수 있다.)
- Expression과 관련이 있는 오퍼레이션이 많을 거라고 상상할 수 있다. 만약에 모든 오퍼레이션을 Expression에만 추가한다면 Expression은 무한히 커질 것이다.

이런 생각들이 충분한 이유가 되진 않겠지만, 당장 이렇게 진행하기로 결정하기엔 부족함이 없다. 또한 Bank가 별 필요가 없게 된다면 축약을 구현할 책임을 Expression으로 기꺼이 옮길 생각도 있다.

이 간단한 예제에서 Bank가 할 일은 정말 하나도 없다. 일단 객체만 하나 있다면 오케이다.

```kotlin
fun testSimpleAddition() {
    val five = Money.dollar(5)
    val sum : Expression = five.plus(five)
    val reduced : Bank = Bank().reduce(sum, "USD")
    assertEquals(Money.dollar(10), reduced)
}
```

이걸 컴파일하려면 일단 Expression 인터페이스가 필요하다. (클래스로 만들어도 되겠지만 인터페이스가 더 가볍다.)

```kotlin
interface Expression
```

Money에 Money.plus()를 만들고 Expression를 구현하게 하자.

```kotlin
open class Money(
    ...
): Expression {
		...
    fun plus(addend: Money): Expression {
        return Money(amount + addend.amount, currency)
    }
		...
}
```

이제 빈 Bank 클래스가 필요하다.

```kotlin
class Bank
```

Bank에는 reduce()의 스텁이 있어야 한다.

```kotlin
class Bank {
    fun reduce(source: Expression, to: String): Money {
        return Money.dollar(10)
    }
}
```

다시 초록 막대로 돌아왔고 리팩토링 할 준비가 됐다. 그 전에 지금까지 한 것을 검토해보자.

우리는

- 큰 테스트를 작은 테스트로 줄여 발전을 나타낼 수 있도록 했다.
- 우리에게 필요한 계산(computation)에 대한 가능한 메타포들을 신중히 생각해봤다.
- 새 메타포에 기반해 기존의 테스트를 재작성했다.
- 테스트를 빠르게 컴파일했다.
- 그리고 테스트를 실행했다.
- 진짜 구현을 만들기 위해 필요한 리팩토링을 기대했다.