# 2장 타락한 객체

### TDD 주기

1. 테스트를 작성한다. 
    
    오퍼레이션 코드가 어떤 식으로 나타나길 원하는지, 이야기를 써내려간다. 
    
    원하는 인터페이스를 개발해라. 올바른 답을 얻기 위해 필요한 이야기의 모든 요소를 포함시켜라.
    
2. 실행 가능하게 만든다.
    
    가장 중요한 것은 빨리 초록 막대를 보는 것이다. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라.
    
    만약 그런 해법이 있지만 구현하는데 몇 분 정도 걸릴 거 같으면 일단 적어 놓은 뒤에 원래 문제로 돌아오자.(초록 막대를 보는 것)
    
3. 올바르게 만든다.
    
    이제 시스템이 작동하므로 직전에 저지른 죄악을 수습하자. 좁고 올곧은 소프트웨어 정의의 길로 되돌아와서 중복을 제거하고 초록 막대로 되돌리자.
    

### 목적은 “작동하는 깔끔한 코드"를 얻는 것이다.

divide and conquer. 나누어서 정복하자.

일단 ‘작동하는 깔끔한 코드'를 얻어야 한다는 전체 문제 중에서 ‘작동하는'에 해당하는 부분을 먼저 해결하자.

그 이후에 ‘깔끔한 코드' 부분을 해결하는 것이다.

이런 접근 방식은 ‘깔끔한 코드' 부분을 먼저 해결한 후에 ‘작동하는’ 부분을 해결해 가면서 배운 것들을 설계에 반영하느라 허둥거리는 아키텍처 주도 개발과 정반대다.

### 할 일 목록

- $5 + 10CHF = $10(환율이 2:1일 경우)
- ~~$5 * 2 = $10~~
- amount를 private으로 만들기
- **Dollar 부작용(side effect)?**
- Money 반올림?

테스트를 통과했지만 뭔가 이상하다. 바로 Dollar에 대한 연산을 수행한 후 해당 Dollar의 값이 바뀌는 점이다.

나는 다음과 같이 쓸 수 있길 바란다.

```kotlin
fun testMultiplication() {
    val five = Dollar(5)
    five.times(2)
    assertEquals(10, product.amount)
    five.times(3)
    assertEquals(15, product.amount)
}
```

하지만 이 테스트를 통과할 방법이 생각나지 않는다. times()를 호출한 이후 five는 더 이상 5가 아니다. 

그렇다면 times에서 새로운 객체를 반환하게 만들면 어떨까? 그렇게 하면 원래의 5달러를 가지고 온종일 곱하기를 수행해도 원래 5달러 값은 변하지 않을 것이다. 이렇게 하려면 Dollar의 인터페이스를 수정해야 하고, 그러기 위해서는 테스트도 수정해야 한다. 어떤 구현이 올바른가에 대한 우리 추측이 완벽하지 못한 것과 마찬가지로 올바른 인터페이스에 대한 추측 역시 절대 완벽하지 못하다.

```kotlin
fun testMultiplication() {
        val five = Dollar(5)
        var product = five.times(2)
        assertEquals(10, product.amount)
        product = five.times(3)
        assertEquals(15, product.amount)
}
```

현재 amount 때문에 컴파일 조차 되지 않는다. 이를 위해 Dollar 클래스에서 올바른 금액을 갖는 Dollar를 리턴하게 해야 한다.

```kotlin
class Dollar(
    var amount: Int
) {

    fun times(multiplier: Int): Dollar {
        return Dollar(amount * multiplier)
    }
}
```

### 할 일 목록

- $5 + 10CHF = $10(환율이 2:1일 경우)
- ~~$5 * 2 = $10~~
- amount를 private으로 만들기
- ~~Dollar 부작용(side effect)?~~
- Money 반올림?

다음은 최대한 빨리 초록색을 보기 위해 취할 수 있는 내가 아는 3가지 전략 중 2가지다.

- 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
- 명백한 구현 사용하기 : 실제 구현을 입력한다.

모든 일이 자연스럽고 잘 진행되고 내가 뭘 입력해야 할 지 알 때는 명백한 구현을 계속 더해 나간다. 예상치 못한 빨간 막대가 나타나면 뒤로 한 발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다. 그러다 자신감을 다시 찾으면 명백한 구현 사용하기 모드로 돌아온다.

3장에서 보게 될 삼각측량(trianglulation)이라 부르는 세 번째 방법도 있는데, 일단 지금까지 배운 것을 검토해보자.

우리는 

- 설계상의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다.
- 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
- 올바르다고 생각하는 코드를 입력해 테스트를 통과했다.

느낌을 테스트로 변환하는 것은 TDD의 일반적 주제다. 이런 작업을 오래 할 수록 미적 판단을 테스트로 담아내는 것에 점점 익숙해지게 된다. 이걸 할 수 있을 때, 설계 논의는 훨씬 더 흥미로워진다. 우선 시스템이 이런 식으로 동작해야 하는지 저런 식으로 동작해야 하는지 논의할 수 있다. 

일단 올바른 행위에 대해 결정을 내린 후에, 그 행위를 얻어낼 수 있는 최상의 방법에 대해 이야기할 수 있다. 술을 마시는 동안에 참과 아름다움에 관해 모든 걸 상상할 수 있지만, 프로그래밍하는 동안에는 그런 상상의 토론은 접어두고 단지 구체적 사례에 대해 이야기할 수 있다.